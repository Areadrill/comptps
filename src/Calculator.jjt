options
{
 LOOKAHEAD=1;
}
PARSER_BEGIN(Calculator)
import java.util.Hashtable;
public class Calculator
{
  Hashtable symbolTable = new Hashtable();
  
 public static void main(String args[]) throws ParseException {
	Calculator myCalc = new Calculator(System.in);
	SimpleNode root = myCalc.Program(); // devolve referência para o nó raiz da árvore

	root.dump(""); // imprime no ecrã a árvore
	System.out.println("Valor da expressão: "+myCalc.eval(root));
 }
int eval(SimpleNode node) {

	if(node.id == CalculatorTreeConstants.JJTPROGRAM)
	{
		for(int i = 0; i < node.jjtGetNumChildren(); i++)
		{
		  eval((SimpleNode)node.jjtGetChild(i));
		  
		}
	}
  
	if(node.jjtGetNumChildren() == 0) // leaf node with integer value
		return node.val;
	else if(node.jjtGetNumChildren() == 1) // only one child
		return this.eval((SimpleNode) node.jjtGetChild(0));

	
	SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child
	SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child
	switch(node.id) {
		case CalculatorTreeConstants.JJTADD : return eval( lhs ) + eval( rhs );
		case CalculatorTreeConstants.JJTSUB : return eval( lhs ) - eval( rhs );
		case CalculatorTreeConstants.JJTMUL : return eval( lhs ) * eval( rhs );
		case CalculatorTreeConstants.JJTDIV : return eval( lhs ) / eval( rhs );
		case CalculatorTreeConstants.JJTASSIGNMENT: return eval(rhs);
		default : // abort
			System.out.println("Operador ilegal!");
			System.exit(1);
	}
	return 0;
}
} 

PARSER_END(Calculator)
SKIP :
{
" " | "\r" | "\t"
}
TOKEN:
{
 < INTEGER: (["0"-"9"])+ >
| < LF: "\n" >
| < SEPARATOR: ";" >
| < VARIABLE: (["A"-"Z"]|["a"-"z"] (["0"-"9"]|["A"-"Z"]["a"-"z"])*) >
| < FIN: "." >
}

SimpleNode Program(): {}
{	((Assignment() | Expr1()) < SEPARATOR > (<LF >)*)+ < FIN >	{	  return jjtThis;
	}
}
SimpleNode Assignment(): {}
{
  < VARIABLE > "=" Expr1() {return jjtThis;}}
SimpleNode Expression(): {}
{
 Expr1() <LF> {return jjtThis;} // código Java entre chavetas
}
void Expr1() #void: {}
{
 Expr2(1) [("+" Expr2(1) #Add(2)| "-" Expr2(1) #Sub(2))]
}	

void Expr2(int sign) #void: {}
{
 Expr3(sign) [("*" Expr3(1) #Mul(2) | "/" Expr3(1) #Div(2))]
 }
void Expr3(int sign) #void: {Token t;}
{
 t = <INTEGER> {
   jjtThis.val = Integer.parseInt(t.image) * sign; } #Term
 | "-" Expr3(-1)
 | "(" Expr1() ")"
}